前言

-----

2019版多线程与高并发(马士兵)

各位同学，大家好，这是首次使用比较口语化的文字形成一本书，其实也不知道效果如何，希望各位收
到书本后能够多提意见和建议。同时也请大家体谅，由于时间关系和忙碌程度，暂时只能总结成为口语
化的形式，后面时间充裕了，将会将会以书面语言的方式进行重新更新。

# 第一节：线程的基本概念

----

首先大家交代一下我们2019年这个版本给大家讲哪些内容，这个版本主要之中在多线程和高并发这两 大块，这两大块儿是现在面试问的越来越多，也是相对一个初级的程序员向中高级迈进的必须要踏过的 一个坎儿。

多线程与高并发大概讲六大块，

* 第一:**基本的概念**，从什么是线程开始
* 第二:**JUC****同步工具**，就是各种同步锁
* 第三:**同步容器**
* 第四:**线程池** 
* 第五:**高频面试加分项**的一些面试用的东西，包括纤程 
* 第六:**Disruptor**，不知道有多少同学听说过这个框架的，这个框架它也是一个MQ框架 (Message Queue)叫做消息队列，消息队列非常多，后面还会给大家讲Kafka、RabbitMQ， Redis等这些都是消息队列。Disruptor是目前大家公认的在单机环境上效率最高的、性能最快的 MQ。

![多线程与高并发2019](/Users/dev/Desktop/多线程/img/多线程与高并发2019.png)

***我们先说一下为什么要讲多线程和高并发?***

原因是，你想拿到一个更高的薪水，在面试的时候呈现出了两个方向的现象: 

第一个是**上天**

* 项目经验
* 高并发 缓存 大流量 大数据量的架构设计

第二个是**入地** 

* 各种基础算法，各种基础的数据结构

* JVM OS 线程 IO等内容 

多线程和高并发，就是**入地**里面的内容。

**基本概念**

我们先从线程的基本概念开始，给大家复习一下，不知道有多少同学是基础不太好，说什么是线程都不
知道的，如果这样的话，花时间去补初级内容的课。

![image-20200614183901177](/Users/dev/Library/Application Support/typora-user-images/image-20200614183901177.png)

什么是叫一个进程? 什么叫一个线程?

* Program app ->QQ.exe

**进程:**做一个简单的解释，你的硬盘上有一个简单的程序，这个程序叫QQ.exe，这是一个程序， 这个程序是一个静态的概念，它被扔在硬盘上也没人理他，但是当你双击它，弹出一个界面输入账 号密码登录进去了，OK，这个时候叫做一个进程。进程相对于程序来说它是一个动态的概念

**线程:**作为一个进程里面最小的执行单元它就叫一个线程，用简单的话讲一个程序里不同的执行路 径就叫做一个线程

**示例:什么叫做线程**

```java
package com.mashibing.juc.c_000;
import java.util.concurrent.TimeUnit;
public class T01_WhatIsThread {
  private static class T1 extends Thread {
    @Override
    public void run() {
       for(int i=0; i<10; i++) {
           try {
               TimeUnit.MICROSECONDS.sleep(1);
           } catch (InterruptedException e) {
               e.printStackTrace();
}
           System.out.println("T1");
       }
} }
  
public static void main(String[] args) {
    //new T1().run();
    new T1().start();
    for(int i=0; i<10; i++) {
    try {
        TimeUnit.MICROSECONDS.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
}
    System.out.println("main");
}


```

观察上面程序的数据结果，你会看到字符串“T1”和“Main”的交替输出，这就是程序中有两条不同的执行 路径在交叉执行，这就是直观概念上的线程，***概念性的东西，理解就好，没有必要咬文嚼字的去背文字 的定义***。

**创建线程的几种方式**

} }

```java

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.FutureTask;
public class T02_HowToCreateThread {

    static class MyThread extends Thread {
         @Override
        public void run() {
            System.out.println("Hello MyThread!");
    } 
     }
    static class MyRun implements Runnable {
        @Override
        public void run() {
            System.out.println("Hello MyRun!");
} }

   static class MyCall implements Callable<String> {
        @Override
        public String call() {
            System.out.println("Hello MyCall");
            return "success";
} }
  
  //启动线程的5种方式
public static void main(String[] args) {
       // 1:
        new MyThread().start();
      // 2:
        new Thread(new MyRun()).start();
     // 3:
        new Thread(()->{
            System.out.println("Hello Lambda!");
        }).start();
     // 4:
        Thread t = new Thread(new FutureTask<String>(new MyCall()));
        t.start();
    // 5:
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(()->{
            System.out.println("Hello ThreadPool");
        });
        service.shutdown();
    }
}

```

**分享一道面试题**

请你告诉我启动线程的三种方式 ?

* 你说第一个:new Thread().start(); 

* 第二个: new Thread(Runnable).start() 这没问题 ;

* 那第三个呢， 要回答线程池也是用的这两种之一，他这么问有些吹毛求疵的意思，你就可以说通过线程池也可以启动 一个新的线程 3:Executors.newCachedThreadPool()或者FutureTask + Callable

```java
package com.mashibing.juc.c_000;
public class T03_Sleep_Yield_Join {
    public static void main(String[] args) {
                    //testSleep();
                    //testYield();
        testJoin();
    }
/*Sleep,意思就是睡眠，当前线程暂停一段时间让给别的线程去运行。Sleep是怎么复活的?由 你的睡眠时间而定，等睡眠到规定的时间自动复活*/
    static void testSleep() {
        new Thread(()->{
            for(int i=0; i<100; i++) {
                System.out.println("A" + i);
                try {
                      Thread.sleep(500);
                  //TimeUnit.Milliseconds.sleep(500)
                } catch (InterruptedException e) {
                    e.printStackTrace();
} }
        }).start();
    }
/*Yield,就是当前线程正在执行的时候停止下来进入等待队列，回到等待队列里在系统的调度算 法里头呢还是依然有可能把你刚回去的这个线程拿回来继续执行，当然，更大的可能性是把原来等待的那些拿 出一个来执行，所以yield的意思是我让出一下CPU，后面你们能不能抢到那我不管*/
    static void testYield() {
        new Thread(()->{
            for(int i=0; i<100; i++) {
                System.out.println("A" + i);
                if(i%10 == 0) Thread.yield();
            }
        }).start();
        new Thread(()->{
            for(int i=0; i<100; i++) {
                System.out.println("------------B" + i);
                if(i%10 == 0) Thread.yield();
            }
        }).start();
    }
/*join， 意思就是在自己当前线程加入你调用Join的线程()，本线程等待。等调用的线程运行 完了，自己再去执行。t1和t2两个线程，在t1的某个点上调用了t2.join,它会跑到t2去运行，t1等待t2运 行完毕继续t1运行(自己join自己没有意义) */
    static void testJoin() {
        Thread t1 = new Thread(()->{
            for(int i=0; i<100; i++) {
                System.out.println("A" + i);
                try {
                    Thread.sleep(500);
                    //TimeUnit.Milliseconds.sleep(500)
                } catch (InterruptedException e) {
                    e.printStackTrace();
} }
        });
        Thread t2 = new Thread(()->{
            try {
                t1.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
}
            for(int i=0; i<100; i++) {
                System.out.println("A" + i);
                try {
                    Thread.sleep(500);
                    //TimeUnit.Milliseconds.sleep(500)
                } catch (InterruptedException e) {
                    e.printStackTrace();
                  } }
});
        t1.start();
        t2.start();
    }
}
```



![image-20200614185015486](/Users/dev/Library/Application Support/typora-user-images/image-20200614185015486.png)

常见的线程状态有六种: 当我们new一个线程时，还没有调用start()该线程处于**新建状态**

线程对象调用 start()方法时候，他会被线程调度器来执行，也就是交给操作系统来执行了，那么操 作系统来执行的时候，这整个的状态叫Runnable，Runnable内部有两个状态

**(1)Ready****就绪状 态**/**

(2)Running运行状态**。就绪状态是说扔到CPU的等待队列里面去排队等待CPU运行，等真正扔到 CPU上去运行的时候才叫Running运行状态。(调用yiled时候会从Running状态跑到Ready状态去，线 程配调度器选中执行的时候又从Ready状态跑到Running状态去)

如果你线程顺利的执行完了就会进去

**(3)Teminated****结束状态**，(需要注意Teminated完了之后还可不 可以回到new状态再调用start?这是不行的，完了这就是结束了)

在Runnable这个状态里头还有其他一些状态的变迁

**(4)TimedWaiting****等待**、**

(5)Waiting等待**、 **

(6)Blocked阻塞**，在同步代码块的情况就下没得到锁就会**阻塞状态**，获得锁的时候是就绪状态运行。在 运行的时候如果调用了o.wait()、t.join()、LockSupport.park()进入**Waiting状态**，调用o.notify()、 o.notifiAll()、LockSupport.unpark()就又回到Running状态。**TimedWaiting**按照时间等待，等时间结 束自己就回去了，

* Thread.sleep(time)、

* o.wait(time)、

* t.jion(time)、

* LockSupport.parkNanos()、

* LockSupport.parkUntil() 这些都是关于时间等待的方法。

** 问题****1****:哪些是****JVM****管理的?哪些是操作系统管理的?**

上面这些状态全是由JVM管理的，因为JVM管理的时候也要通过操作系统，所以呢，那个是操作系统和

那个是JVM他俩分不开，JVM是跑在操作系统上的一个普通程序

**问题****2****:线程什么状态时候会被挂起?挂起是否也是一个状态?**

Running的时候，在一个cpu上会跑很多个线程，cpu会隔一段时间执行这个线程一下，在隔一段时间执 行那个线程一下，这个是cpu内部的一个调度，把这个状态线程扔出去，从running扔回去就叫线程被 挂起，cpu控制它。

来看一下ThraedState这段代码



```java
package com.mashibing.juc.c_000;
public class T04_ThreadState {
    static class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println(this.getState());

          for(int i=0; i<10; i++) {
              try {
                  Thread.sleep(500);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              System.out.println(i);
          }
         }
      }


public static void main(String[] args) {
    Thread t = new MyThread();
    //怎么样得到这个线程的状态呢?就是通过getState()这个方法 
  System.out.println(t.getState());//他是一个new状态
     t.start();//到这start完了之后呢是Runnable的状态
    try {
        t.join();
    } catch (InterruptedException e) {
        e.printStackTrace();
}
//然后join之后，结束了是一个Timenated状态 
  System.out.println(t.getState()); 
 }
}

```

**synchronized**

下面我们来讲synchronized关键字，有不少同学已经耳熟能详了，不过作为复习还是要复习一下。第一 个是多个线程去访问同一个资源的时候对这个资源上锁。

为什么要上锁呢?访问某一段代码或者某临界资源的时候是需要有一把锁的概念在这儿的。

![image-20200614185946179](/Users/dev/Library/Application Support/typora-user-images/image-20200614185946179.png)

比如：我们对一个数字做递增，两个程序对它一块儿来做递增，递增就是把一个程序往上加1啊，如果 两个线程共同访问的时候，第一个线程一读它是0，然后把它加1，在自己线程内部内存里面算还没有写 回去的时候而第二个线程读到了它还是0，加1在写回去，本来加了两次，但还是1，那么我们在对这个 数字递增的过程当中就上把锁，就是说第一个线程对这个数字访问的时候是独占的，不允许别的线程来 访问，不允许别的线程来对它计算，我必须加完1收释放锁，其他线程才能对它继续加。

实质上，这把锁并不是对数字进行锁定的， 你可以任意指定，想锁谁就锁谁。

我第一个小程序是这么写的 ，如果说你想上了把锁之后才能对count进行减减访问，你可以new一个 Object，所以这里锁定就是o，当我拿到这把锁的时候才能执行这段代码。是锁定的某一个对象， synchronized有一个锁升级的概念，我们一会儿会讲到

```java
/**
*synchronized关键字
*对某个对象加锁
*@author mashibing
*/
package com.mashibing.juc.c_001;
public class T {
    private int count = 10;
    private Object o = new Object();
		public void m() {
		synchronized(o) { //任何线程要想执行下面的代码，必须先拿到o的锁
        count--;
        System.out.println(Thread.currentThread().getName() + " count = " +count); 
		} 
	} 
}
```

***如果你要是锁定当前对象呢***，你也可以写成如下方法。synchronized方法和synchronized(this)执行这 段代码它是等值的

```java
package com.mashibing.juc.c_003;
public class T {
    private int count = 10;
    public synchronized void m() { //等同于在方法的代码执行时要synchronized(this) count--;
    System.out.println(Thread.currentThread().getName() + " count = " +count);

	} 
}
```

静态方法static是没有this对象的，你不需要new出一个对象来就能执行这个方法，但如果这个 这个上面加一个synchronized的话就代表synchronized(T.class)。这里这个synchronized(T.class)锁的 就是T类的对象

```java
package com.mashibing.juc.c_004;
public class T {
    private static int count = 10;
    //这里等同于synchronized(T.class) count--;
    public synchronized static void m() { 
         System.out.println(Thread.currentThread().getName() + " count = " +count);
}
public static void mm() {
  //考虑一下这里写synchronized(this)是否可以?
 synchronized(T.class) { 
 	count --; 
 	}
 }
}


```

**问题:****T.class****是单例的吗?**

一个class load到内存它是不是单例的，想想看。一般情况下是，如果是在同一个ClassLoader空间那它 一定是。不是同一个类加载器就不是了，不同的类加载器互相之间也不能访问。所以说你能访问它，那 他一定就是单例

下面程序:很有可能读不到别的线程修改过的内容，除了这点之外count减减完了之后下面的count输 出和你减完的结果不对，很容易分析:如果有一个线程把它从10减到9了，然后又有一个线程在前面一 个线程还没有输出呢进来了把9又减到了8，继续输出的8，而不是9。如果你想修正它，前面第一个是在 上面加volatile，改了马上就能得到。

```java

/**
 * 分析一下这个程序的输出 
* @author mashibing
*  */
package com.mashibing.juc.c_005;
public class T implements Runnable {
    private /*volatile*/ int count = 100;
    public /*synchronized*/ void run() {
        count--;
        System.out.println(Thread.currentThread().getName() + " count = " +
count);
}
 public static void main(String[] args) {
        T t = new T();
        for(int i=0; i<100; i++) {
            new Thread(t, "THREAD" + i).start();
            } 
            }

}
```

另外这个之外还可以加***synchronized***，加了synchronized就没有必要在加volatile了，因为 synchronized既保证了原子性，又保证了可见性

//对比上一个小程序
 package com.mashibing.juc.c_006; public class T implements Runnable {

```
    private int count = 10;
    public synchronized void run() {
        count--;
          System.out.println(Thread.currentThread().getName() + " count = " +
count);
    }
    public static void main(String[] args) {
} }
for(int i=0; i<5; i++) {
    T t = new T();
    new Thread(t, "THREAD" + i).start();
}



```



如下代码:同步方法和非同步方法是否可以同时调用?就是我有一个synchronized的m1方法，我调用 m1的时候能不能调用m2，拿大腿想一想这个是肯定可以的，线程里面访问m1的时候需要加锁，可是 访问m2的时候我又不需要加锁，所以允许执行m2。

这些小实验的设计是比较考验功力的，学习线程的时候自己要多动手进行试验，任何一个理论，都可以
进行验证.

```java
/** *同步和非同步方法是否可以同时调用? * @author mashibing
*/
package com.mashibing.juc.c_007;
public class T {
    public synchronized void m1() {
        System.out.println(Thread.currentThread().getName() + " m1 start...");
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + " m1 end");
    }
    public void m2() {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + " m2 ");
    }
    public static void main(String[] args) {
        T t = new T();
        /*new Thread(()->t.m1(), "t1").start();
        new Thread(()->t.m2(), "t2").start();*/
				new Thread(t::m1, "t1").start();
        new Thread(t::m2, "t2").start();
/*
//1.8之前的写法
new Thread(new Runnable() {
    @Override
    public void run() {
t.m1(); }
});
*/
      
    }
}
```



我们在来看一个synchronized应用的例子

我们定义了一个class账户，有名称、余额。写方法给哪个用户设置它多少余额，读方法通过这个名字得 到余额值。如果我们给写方法加锁，给读方法不加锁，你的业务允许产生这种问题吗?业务说我中间读 到了一些不太好的数据也没关系，如果不允许客户读到中间不好的数据那这个就有问题。正因为我们加 了锁的方法和不加锁的方法可以同时运行。

**问题**比如说:张三，给他设置100块钱启动了，睡了1毫秒之后呢去读它的值，然后再睡2秒再去读它的 值这个时候你会看到读到的值有问题，原因是在设定的过程中this.name你中间睡了一下，这个过程当 中我模拟了一个线程来读，这个时候调用的是getBalance方法，而调用这个方法的时候是不用加锁的， 所以说我不需要等你整个过程执行完就可以读到你中间结果产生的内存，这个现象就叫做脏读。这问题 的产生就是synchronized方法和非synchronized方法是同时运行的。**解决**就是把getBalance加上 synchronized就可以了，如果你的业务允许脏读，就可以不用加锁，加锁之后的效率低下



```
/**
* 面试题:模拟银行账户
* 对业务写方法加锁
* 对业务读方法不加锁
* 这样行不行? *
* 容易产生脏读问题(dirtyRead) */
package com.mashibing.juc.c_008;
import java.util.concurrent.TimeUnit;
public class Account {
    String name;
    double balance;
    public synchronized void set(String name, double balance) {
        this.name = name;
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
  this.balance = balance;
    }
    public /*synchronized*/ double getBalance(String name) {
        return this.balance;
}
    public static void main(String[] args) {
        Account a = new Account();
        new Thread(()->a.set("zhangsan", 100.0)).start();
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
}
        System.out.println(a.getBalance("zhangsan"));
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
}
        System.out.println(a.getBalance("zhangsan"));
    }
}        
        

```

再来看synchronized的另外一个属性:可重入，是synchronized必须了解的一个概念。

如果是一个同步方法调用另外一个同步方法，有一个方法加了锁，另外一个方法也需要加锁，加的是同 一把锁也是同一个线程，那这个时候申请仍然会得到该对象的锁。比如说是synchronized可重入的，有 一个方法m1 是synchronized有一个方法m2也是synchrionzed，m1里能不能调m2。我们m1开始的时 候这个线程得到了这把锁，然后在m1里面调用m2，如果说这个时候不允许任何线程再来拿这把锁的时 候就死锁了。这个时候调m2它发现是同一个线程，因为你m2也需要申请这把锁，它发现是同一个线程 申请的这把锁，允许，可以没问题，这就叫可重入锁。

```
/**
* 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到
该对象的锁。
* 也就是说synchronized获得锁是可重入的 * synchronized
* @author mashibing
*/
package com.mashibing.juc.c_009;
import java.util.concurrent.TimeUnit;
public class T {
    synchronized void m1() {
    System.out.println("m1 start");
    try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        m2();
        System.out.println("m1 end");
}
    synchronized void m2() {
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("m2");
    }
    public static void main(String[] args) {
        new T().m1();
} }
```

模拟一个父类子类的概念，父类synchronized，子类调用super.m的时候必须得可重入，否则就会出问 题(调用父类是同一把锁)。所谓的重入锁就是你拿到这把锁之后不停加锁加锁，加好几道，但锁定的 还是同一个对象，去一道就减个1，就是这么个概念。

```java
/* 程序在执行过程中，如果出现异常，默认情况锁会被释放
* 所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。
* 比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适， * 在第一个线程中抛* 出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。
* 因此要非常小心的处理同步业务逻辑中的异常
* @author mashibing
*/
package com.mashibing.juc.c_011;

import java.util.concurrent.TimeUnit;

public class T {
    int count = 0;

    synchronized void m() {
        System.out.println(Thread.currentThread().getName() + " start");
        while (true) {
            count++;
            System.out.println(Thread.currentThread().getName() + " count = " +
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (count == 5) {
                // 此处抛出异常，锁将被释放，要想不被释放，可以在这里进行
                // catch，然后让循环继续 
                int i = 1 / 0;
                System.out.println(i)
            }
        }
    }

    public static void main(String[] args) {
        T t = new T();
        Runnable r = new Runnable() {
            @Override
            public void run() {
                t.m();
            }
        };
        new Thread(r, "t1").start();
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(r, "t2").start();
    }
}


```

**synchronized****的底层实现**

* 早期，jdk早期的时候，这个synchronized的底层实现是重量级的，重量级到这个synchronized都 是要去找操作系统去申请锁的地步，这就会造成synchronized效率非常低，java后来越来越开始 处理高并发的程序的时候，很多程序员都不满意，说这个synchrionized用的太重了，我没办法， 就要开发新的框架，不用你原生的了

* 改进，后来的改进才有了锁升级的概念
     关于这个锁升级的概念，我写过一篇文章《我就是厕所所长一、二》，大家可以去找一下，公
    众号里也有，专门以小说的形式讲了这个锁升级到底是怎么样的一个概念

![Screen Shot 2020-06-05 at 9.08.27 PM](/Users/dev/Desktop/Screen Shot 2020-06-05 at 9.08.27 PM.png)  

  

  这个锁升级的概念呢，是这样的，原来呢都要去找操作系统，要找内核去申请这把锁，到后期做了对 synchronized的一些改进，他的效率比原来要改变了不少，改进的地方。当我们使用synchronized的 时候HotSpot的实现是这样的:上来之后第一个去访问某把锁的线程 比如sync (Object) ，来了之后先在 这个Object的头上面markword记录这个线程。(如果只有第一个线程访问的时候实际上是没有给这个 Object加锁的，在内部实现的时候，只是记录这个线程的ID(**偏向锁**))。

  偏向锁如果有线程争用的话，就升级为**自旋锁**，概念就是(有一个哥们儿在蹲马桶 ，另外来了一个哥 们，他就在旁边儿等着，他不会跑到cpu的就绪队列里去，而就在这等着占用cpu，用一个while的循环 在这儿转圈玩儿， 很多圈之后不行的话就再一次进行升级)。

  自旋锁转圈十次之后，升级为**重量级锁**，重量级锁就是去操作系统那里去申请资源。这是一个锁升级的 过程。

  参考:https://blog.csdn.net/baidu_38083619/article/details/82527461 需要注意并不是CAS的效率就一定比系统锁要高，这个要区分实际情况:

  ***执行时间短(加锁代码)，线程数少，用自旋***
  ***执行时间长，线程数多，用系统锁***

  

  关于效率方面的内容如果暂时不能理解的，等讲到CAS锁的时候再说。

   **内容回顾**

  线程的概念、启动方式、常用方法 

  * synchronized(Object) 不能用String常量 Integer Long 

  * 线程同步 -synchronized

    - 锁的是对象不是代码

    - this XX.class
    -  -锁定方法 非锁定方法 同时执行

    - 锁升级

  偏向锁 记录这个线程的ID
   自旋锁 如果线层争用，就升级为自旋锁(线程数量少) 重量级锁 10次(线程数量多)

  

 

  /**
   \* volatile 关键字，使一个变量在多个线程间可见
   \* A B线程都用到一个变量，java默认是A线程中保留一份copy,这样如果B线程修改了该变量，则A线程未

  必知道

  - \*  使用volatile关键字，会让所有线程都会读到变量的修改值 *

  - \*  在下面的代码中，running是存在于堆内存的t对象中

  - \*  当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个

    copy,并不会每次都去

  - \*  读取堆内存，这样，当线程修改running的值之后，t1线程感知不到，所以不会停止运行 *
  - \*  使用volatile，将会强制所有线程都会去堆内存中读取running的值 *
  - \*  可以阅读这个文章加深讲解
     \* http://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html *

  \* volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能

  替代synchronized
   \* @author mashibing */

  ```
  package com.mashibing.juc.c_012_Volatile;
  import java.util.concurrent.TimeUnit;
  ```

  public class T01_HelloVolatile {
   /*volatile*/ boolean running = true; //对比一下有无volatile的情况下，整个程序运行

  结果的区别

  ```
      void m() {
          System.out.println("m start");
          while(running) {
          }
          System.out.println("m end!");
  ```

  }

  ```
      public static void main(String[] args) {
          T01_HelloVolatile t = new T01_HelloVolatile();
  ```



# 第二节：volatile 与 CAS

### volatile

  我们先来看这个volatile的概念，volatile它是什么意思，现在像大的互联网企业的面试，基本上volatile 是必会的，有时候他也不会太问，认为你应该会，但是中小企业也就开始问这方面的问题。

  我们来看一下这个小程序，写了一个方法啊，首先定义了一个变量布尔类型等于true，这里模拟的是一 个服务器的操作，我的值为true你就给我不间断的运行，什么时候为false你再停止。 测试new Thread 启动一个线程，调用m方法，睡了一秒，最后running等于false，运行方法他是不会停止的。 如果你要 吧volatile打开，那么结果就是启动程序一秒之后他就会m end停止。(volatile就是不停的追踪这个 值，时刻看什么时候发生了变化)



```java
/**
* volatile 关键字，使一个变量在多个线程间可见
* A B线程都用到一个变量，java默认是A线程中保留一份copy,这样如果B线程修改了该变量，则A线程未
必知道
* 使用volatile关键字，会让所有线程都会读到变量的修改值 *
* 在下面的代码中，running是存在于堆内存的t对象中
* 当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个
copy,并不会每次都去
* 读取堆内存，这样，当线程修改running的值之后，t1线程感知不到，所以不会停止运行 *
* 使用volatile，将会强制所有线程都会去堆内存中读取running的值 *
* 可以阅读这个文章加深讲解
* http://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html *
* volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能
   替代synchronized
* @author mashibing 
*/
package com.mashibing.juc.c_012_Volatile;

import java.util.concurrent.TimeUnit;

public class T01_HelloVolatile {
    //对比一下有无volatile的情况下，整个程序运行结果的区别
    /*volatile*/ boolean running = true;

    void m() {
        System.out.println("m start");
        while (running) {
        }
        System.out.println("m end!");
    }

    public static void main(String[] args) {
        T01_HelloVolatile t = new T01_HelloVolatile();
        new Thread(t::m, "t1").start();
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        t.running = false;
    }
}



```

***volatile 作用（由于面试常考，必须记住）*** ![02_01](/Users/dev/Desktop/多线程/img/02_01.png)

***

> * 1 保证线程的可见性

大家知道java里面是有堆内存的，堆内存是所有线程共享里面的内存，除了共享的内存之外呢，每个线 程都有自己的专属的区域，都有自己的工作内存，如果说在共享内存里有一个值的话，当我们线程，某 一个线程都要去访问这个值的时候，会将这个值copy一份，copy到自己的这个工作空间里头，然后对 这个值的任何改变，首先是在自己的空间里进行改变，什么时候写回去，就是改完之后会马上写回去。 什么时候去检查有没有新的值，也不好控制。

在这个线程里面发生的改变，并没有及时的反应到另外一个线程里面，这就是线程之间的不可见 ，对这 个变量值加了volatile之后就能够保证 一个线程的改变，另外一个线程马上就能看到。

大家可以去查这个词:MESI ，他的本质上是使用了cpu的一个叫做 高速缓存一致性协议 注:在和面《JVM》的课程中，老师深入讲解了MESI协议和volatile的底层实现。

**2****:禁止指令重新排序**

指令重排序也是和cpu有关系，每次写都会被线程读到，加了volatile之后。cpu原来执行一条指令的时 候它是一步一步的顺序的执行，但是现在的cpu为了提高效率，它会把指令并发的来执行，第一个指令 执行到一半的时候第二个指令可能就已经开始执行了，这叫做流水线式的执行。在这种新的架构的设计 基础之上呢想充分的利用这一点，那么就要求你的编译器把你的源码编译完的指令之后呢可能进行一个 指令的重新排序。

这个是通过实际工程验证了，不仅提高了，而且提高了很多

-DCL单例 我们来聊一聊什么是单例，单例的意思就是我保证你在JVM的内存里头永远只有某一个类的一个实例，

其实这个很容易理解，在我们工程当中有一些类真的没有必要new好多个对象，比如说权限管理者。

单例最简单的写法就是下面这种写法，是说我有一个类，定义了这个类的一个对象，然后一个对象呢是 在个类的内部的，同时我把Mgr01()这个类的构造方法设置成private意思就是别的不要去new我，只有 我自己能new，理论上来说我就只有自己一个实例了，通过getInstance()访问这个实例，所以无论你调 用多少次的getInstanc()本质上它就只有这一个对象，这种写法非常简洁也很容易理解，由JVM来保证永 远只有这一个实例。

```java
 package com.mashibing.dp.singleton;
 /**
 * 饿汉式
 * 类加载到内存后，被实例化一个单例，JVM保证线程安全 * 简单实用，推荐使用!
 * 唯一缺点，不管用到与否，类装载时就完成实例化 * Class.forName("")
 **/
 public class Mgr01{
  private static final Mgr01 INSTANCE = new Mgr01();
  private Mgr01(){};
  public static Mgr01 getInstance(){
    return INSTANCE;
  }
  public void m(){
    System.out.println("m");
  }
  public static void main(String[] args){
    Mgr01 m1=Mgr01.getInstance();
    Mgr01 m2=Mgr02.getInstance();
    System.out.println(m1==m2);
    } 
 }
```

但是有的人，他会吹毛求疵，他会说我还没开始用这个对象呢，没用这个对象调这个方法你干嘛把他初始
化了，你能不能什么时候开始用，调这个方法的时候你再给我初始化。所以呢，下面代码这个是和上一
种一样的写法

```java
package com.mashibing.dp.singleton;

/**
 * 跟01是一个意思
 **/
public class Mgr02 {
    private static final Mgr02 INSTANCE;

    static {
        INSTANCE == new Mgr02();
    }

    private Mgr02() {
    }
    
    public static Mgr02 getInstance() {
        return INSTANCE;
    }

    public void m() {
        System.out.println("m");
    }

    public static void main(String[] args) {
        Mgr02 m1 = Mgr02.getInstance();
        Mgr02 m2 = Mgr02.getInstance();
        System.out.println(m1 == m2);
    }
}


```





### CAS

![Screen Shot 2020-06-05 at 8.25.13 PM](/Users/dev/Desktop/Screen Shot 2020-06-05 at 8.25.13 PM.png)

# 第七节： 线程池

华为的一道面试题，其实它里面是一道填空题，后来就很多的开始考这道题，这 个面试题是两个线程，第一个线程是从1到26，第二个线程是从A到一直到Z，然后要让这两个线程做到 同时运行，交替输出，顺序打印。那么这道题目的解法有非常多。

```java
package com.mashibing.juc.c_026_00_interview.A1B2C3;
public class T01_00_Question {
	public static void main(String[] args) { 
  	//要求用线程顺序打印A1B2C3....Z26
	} 
}
```

用LockSupport其实是最简单的。你让一个线程输出完了之后停止，然后让另外一个线程继续运行就完 了。我们定义了两个数组，两个线程，第一个线程拿出数组里面的每一个数字来，然后打印，打印完叫 醒t2，然后让自己阻塞。另外一个线程上来之后自己先park，打印完叫醒线程t1。两个线程就这么交替 来交替去，就搞定了。

```java
package com.mashibing.juc.c_026_00_interview.A1B2C3;

import java.util.concurrent.locks.LockSupport;

//Locksupport park 当前线程阻塞(停止)
//unpark(Thread t)
public class T02_00_LockSupport {
    static Thread t1 = null, t2 = null;

    public static void main(String[] args) throws Exception {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();
        t1 = new Thread(() -> {
            for (char c : aI) {
                System.out.print(c);
                LockSupport.unpark(t2); //叫醒T2 
                LockSupport.park();    //T1阻塞
            }
        }, "t1");
        t2 = new Thread(() -> {
            for (char c : aC) {
                LockSupport.park(); //t2阻塞
                System.out.print(c);
                LockSupport.unpark(t1); //叫醒t1
            }
        }, "t2");
        t1.start();
        t2.start();
    }
}
	
```

当时出这道题的时候是想考察wait、notify和notifyAll，主要是synchronized、wait、notify。

来解释一下，首先第一个我先调用wait、notify的时候，wait线程阻塞，notify叫醒其他线程，调用这个 两个方法的时候必须要进行synchronized锁定的，如果没有synchronized这个线程你是锁定不了的， 他是离开不锁的，因此我们定义一个锁的对象new Object()，两个数组，第一线程上来先锁定Object对 象 o，锁定完对象之后，我们开始输出，输出第一个数字，输出完之后叫醒第二个，然后自己wait。还 是这个思路，其实这个就和LookSupport的park、unpark是非常类似的，这里面最容易出错的一个地 方就是把整个数组都打印完了要记得notify，为什么要notify啊，因为这两个线程里面终归有一个线程 wait的，是阻塞在这停止不动的。

```java
package com.mashibing.juc.c_026_00_interview.A1B2C3;

public class T06_00_sync_wait_notify {
    public static void main(String[] args) {
        final Object o = new Object();
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();
        new Thread(() -> {
            synchronized (o) {
                for (char c : aI) {
                    System.out.print(c);
                    try {
                        o.notify();
                        o.wait(); //让出锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                o.notify(); //必须，否则无法停止程序 }
            },"t1").start();
        
            new Thread(() -> {
                synchronized (o) {
                    for (char c : aC) {
                        System.out.print(c);
                        try {
                            o.notify();
                            o.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    o.notify();
                }
            }, "t2").start();
        }
    }
}

//如果我想保证t2在t1之前打印，也就是说保证首先输出的是A而不是1，这个时候该如何做
```

保证第一个线程先运行，办法也是非常的多的，看下面，使用自旋的方式，设置一个boolean类型的变 量，t2刚开始不是static。如果说t2没有static的话，我这个t1线程就wait，要求t2必须先static才能执行 我的业务逻辑。还有一种写法就是t2上来二话不说先wait，然后t1呢上来二话不说先输出，输出完了之 后notify;还有一种写法用CountDownLatch也可以;

```java
package com.mashibing.juc.c_026_00_interview.A1B2C3;

public class T07_00_sync_wait_notify {
    private static volatile boolean t2Started = false;

    //private static CountDownLatch latch = new C(1);
    public static void main(String[] args) {
        final Object o = new Object();
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();
        new Thread(() -> {
            //latch.await();
            synchronized (o) {
                while (!t2Started) {
                    try {
                        o.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                for (char c : aI) {
                    System.out.print(c);
                    try {
                        o.notify();
                        o.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                o.notify();
            }
        }, "t1").start();
        new Thread(() -> {
            synchronized (o) {
                for (char c : aC) {
                    System.out.print(c);
                    //latch.countDown()
                    t2Started = true;
                    try {
                        o.notify();
                        o.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                o.notify();
            }
        }, "t2").start();
    }
}
```

​       这两种最重要的方法，一个是***LockSupport***，一个是***synchronized、wait、notify***。这两种面试的时候 你要是能写出来问题就不大，但是，你如果能用新的***lock***的接口，就不再用***synchronized***，用这种自旋 的，也可以。严格来讲这个lock和synchronized本质是一样的。不过他也有好用的地方，下面我们来看 看写法。

严格来讲这个lock和synchronized本质是一样的，不过还是有它好用的地方，

* 我们来看看它的第一种写 法我用一个ReentrantLock，然后调用newCondition，上来之后先lock相当于synchronized了，打印， 打印完之后signal叫醒另一个当前的等待，最后***condition.signal()***相当于***notify()***，然后之后另外一个也 类似就完了，这种写法相当于***synchronized***的一个变种。 

```java
package com.mashibing.juc.c_026_00_interview.A1B2C3;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class T08_00_lock_condition {
    public static void main(String[] args) {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();
        Lock lock = new ReentrantLock();
        Condition condition = lock.newCondition();
        new Thread(() -> {
            try {
                lock.lock();
                for (char c : aI) {
                    System.out.print(c);
                    condition.signal();
                    condition.await();
                }
                condition.signal();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }, "t1").start();
      
        new Thread(() -> {
            try {
                lock.lock();
                for (char c : aC) {
                    System.out.print(c);
                    condition.signal();
                    condition.await();
                }

                condition.signal();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }, "t2").start();
    }
}
                
```

但是如果你能写出两个Condition的情况就会好很多。大家知道，在一个一把锁，这个锁的等待队列里 有好多线程，假如我要notify的话他实际上要找出一个让它运行，如果说我要调用的是一个notifyAll的 话，是让所有线程都醒过来去争用这把锁看谁能抢的到，谁抢到了就让这个线程运行。

那好，在这里面 呢，我不能去要求那一类或者那一个线程去醒过来，这个回想原来讲过的***生产者消费者***的问题，既然我 们有两个线程，那完全可以模仿生产者和消费者我干脆来两种的Condition，同学们也回顾一下，给大 家讲***Condition***的时候说过这个问题，***Condition它本质上是一个等待队列 ，就是两个等待队列***，其中 一个线程在这个等待队列上，另一个线程在另外一个等待队列上。

所以呢，如果说我用两个Condition的话就可以精确的指定那个等待队列里的线程醒过来去执行任务。 所以这个写法就是这样来写的，第一线程呢***conditionT2.signal()***，***叫醒第二个那个里面的线程***，然后我 第一个线程让它等待，第二个就是我叫醒第一个线程，第二个让它等待放到这个等待队列里，相当于我 放了两个等待队列，t1在这个等待队列里，t2在另一个等待队列里，在t1完成了之后呢叫醒t2是指定你 这个队列的线程醒过来，所以永远都是t2。其实对于两个线程来讲区别不大，因为你叫醒的时候当前线程肯定是醒着的，叫醒的也就只有是你这个线程 ，不过对于写代码来说，写到这个样子面试官肯定是会 高看你一眼。

```java
/*
 * Condition本质是锁资源上不同的等待队列
 */
package com.mashibing.juc.c_026_00_interview.A1B2C3;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class T09_00_lock_condition {
    public static void main(String[] args) {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();
        Lock lock = new ReentrantLock();
        Condition conditionT1 = lock.newCondition();
        Condition conditionT2 = lock.newCondition();
        new Thread(() -> {
            try {
                lock.lock();
                for (char c : aI) {
                    System.out.print(c);
                    conditionT2.signal();
                    conditionT1.await();
                }

                conditionT2.signal();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }, "t1").start();
        new Thread(() -> {
            try {
                lock.lock();
                for (char c : aC) {
                    System.out.print(c);
                    conditionT1.signal();
                    conditionT2.await();
                }
                conditionT1.signal();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }, "t2").start();
    }
}


```

在这里，用一个自旋式的写法，就是我们没有锁，相当于自己写了一个自旋锁。***cas***的写法，这个写法 用了enum，到底哪个线程要运行他只能取两个值，T1和T2，然后定义了一个ReadyToRun的变量，刚 开始的时候是T1，这个意思呢就相当于是我有一个信号灯，这个信号灯要么就是T1要么就是T2，只能 取这个两个值，不能取别的，当一开始的时候我在这个信号灯上显示的是T1，T1你可以走一步。看程 序，第一上来判断是不是T1啊，如果不是就占用cpu在这循环等待，如果一看是T1就打印，然后把r值 变成T2进行下一次循环，下一次循环上来之后这个r是不是T1，不是T1就有在这转圈玩儿，而第二个线 程发现它变成T2了，变成T2了下面的线程就会打印A，打印完了之后有把这个r变成了T1，就这么交替 交替，就是这个一种玩法，写volatile是保证线程的可见性。为什么要用enum类型，就是防止它取别的 值，用一个int类型或者布尔也都可以。

```java
package com.mashibing.juc.c_026_00_interview.A1B2C3;

public class T03_00_cas {
    enum ReadyToRun {T1, T2}
    static volatile ReadyToRun r = ReadyToRun.T1; //思考为什么必须volatile
    public static void main(String[] args) {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();
        new Thread(() -> {
            for (char c : aI) {
                while (r != ReadyToRun.T1) {
                }
                System.out.print(c);
                r = ReadyToRun.T2;
            }
        }, "t1").start();
        new Thread(() -> {
            for (char c : aC) {
                while (r != ReadyToRun.T2) {
                }
                System.out.print(c);
                r = ReadyToRun.T1;
            }
        }, "t2").start();

    }
}
```

在来看一个**BlockingQueue**的玩法，上节课呢讲了BlockingQueue了，它有一个特点， BlockingQueue可以支持多线程的阻塞操作，他有两个操作一个是put，一个take。put的时候满了他就 会阻塞住，take的时候如果没有，他就会阻塞住在这儿等着，我们利用这个特点来了两个 BlockingQueue，这两个BlockingQueue都是ArrayBlockingQueue数组实现的，但是数组的长度是1， 相当于我用了两个容器，这两个容器里头放两个值，这两个值比如说我第一个线程打印出1来了我就在 这边放一个，我这边OK了，该你了，而另外一个线程盯着这个事，他take，这个take里面没有值的时 候他是要在这里阻塞等待的，take不到的时候他就等着，等什么时候这边打印完了，take到了他就打印 这个A，打印完了A之后他就往第二个里面放一个OK，第一个线程也去take第二个容器里面的OK，什么 时候take到了他就接着往下打印，大概是这么一种玩儿法。

```java
package com.mashibing.juc.c_026_00_interview.A1B2C3;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.locks.LockSupport;

public class T04_00_BlockingQueue {
    static BlockingQueue<String> q1 = new ArrayBlockingQueue(1);
    static BlockingQueue<String> q2 = new ArrayBlockingQueue(1);

    public static void main(String[] args) throws Exception {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();
        new Thread(() -> {
            for (char c : aI) {
                System.out.print(c);
                try {
                    q1.put("ok");
                    q2.take();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "t1").start();
        new Thread(() -> {
            for (char c : aC) {
                try {
                    q1.take();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.print(c);
                try {
                    q2.put("ok");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "t2").start();
    }
}

```

这个效率非常低，它里面有各种的同步，我们了解一下就可以了，基本上面试也问不到这个。这里要把 两个线程连接起来要求的步骤比较多，要求建立一个PipedInputStream和一个PipedOutputStream。 就相当于两个线程通信，第一个这边就得有一个OutputStream，对应第二个线程这边就得有一个 InputStream，同样的第二个要往第一个写的话，第一个也得有一个InputStream，第二个也还得有一 个OutputStream。最后要求你的第一个线程的input1和你第二个线程的output2连接connect起来，互 相之间的扔消息玩儿，这边搞定了告诉另一边儿，另一边儿搞定了告诉这边，回合制。

```java
package com.mashibing.juc.c_026_00_interview.A1B2C3;

import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;

public class T10_00_PipedStream {
    public static void main(String[] args) throws Exception {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();
        PipedInputStream input1 = new PipedInputStream();
        PipedInputStream input2 = new PipedInputStream();
        PipedOutputStream output1 = new PipedOutputStream();
        PipedOutputStream output2 = new PipedOutputStream();
        input1.connect(output2);
        input2.connect(output1);
        String msg = "Your Turn";
        new Thread(() -> {
            byte[] buffer = new byte[9];
            try {
                for (char c : aI) {
                    input1.read(buffer);
                    if (new String(buffer).equals(msg)) {
                        System.out.print(c);
                    }
                    output1.write(msg.getBytes());
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }, "t1").start();
        new Thread(() -> {
            byte[] buffer = new byte[9];
            try {
                for (char c : aC) {
                    System.out.print(c);
                    output2.write(msg.getBytes());
                    input2.read(buffer);
                    if (new String(buffer).equals(msg)) {
                        continue;
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }, "t2").start();
    }
}
```

试了一下，使用 Semaphone 与 Exchanger 是解决不了这个问题的。***(思考为什么?)**

那么TransferQueue是一种什么样的队列呢，就是我一个线程往里头生产，生产者线程往里头生产的时 候，我生产了之后扔在这的时候我这个线程是阻塞的不动的，什么时候有另外一个线程把这个拿走了， 拿走了之后这个线程才返回继续运行。

我这个写法是这样的，我用了一个TransferQueue，我第一个线程上来二话不说先take，相当于第一个 线程做了一个消费者，就在这个Queue等着，看看有没有人往里扔。第二个线程二话不说上来经过 transfer，就把这个字母扔进去了，扔进去了一个A，第一个线程发现很好，来了一个，我就把这个拿 出来打印，打印完之后我又进行transfer，进去了一个1。然后，第二个线程它去里面take，把这个1 take出来打印。这个写法很好玩儿，相当于我们自己每个人都把自己的一个数字或者是字母交到一个队 列里让对方去打印。

```java
package com.mashibing.juc.c_026_00_interview.A1B2C3;

import java.util.concurrent.LinkedTransferQueue;
import java.util.concurrent.TransferQueue;

public class T13_TransferQueue {
    public static void main(String[] args) {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();
        TransferQueue<Character> queue = new LinkedTransferQueue<Character>();
        new Thread(() -> {
            try {
                for (char c : aI) {
                    System.out.print(queue.take());
                    queue.transfer(c);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t1").start();
        new Thread(() -> {
            try {
                for (char c : aC) {
                    queue.transfer(c);
                    System.out.print(queue.take());
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t2").start();
    }
}
```

我们接下来讲高并发这个部分的理论知识的一部分，线程池。 线程池首先有几个接口先了解第一个是Executor，第二个是ExecutorService，在后面才是线程池的一个使用ThreadPoolExecutor.

![Screen Shot 2020-06-19 at 8.25.26 PM](/Users/dev/Desktop/Screen Shot 2020-06-19 at 8.25.26 PM.png)

* Executor看它的名字也能理解，执行者，所以他有一个方法叫执行，那么执行的东西是 Runnable，所以这个Executor有了之后呢由于它是一个借口，他可以有好多实现，因此我们说， 有了Executor之后呢，我们现场就是一个任务的定义，比如Runnable起了一个命令的意思，他的 定义和运行就可以分开了，不像我们以前定义一个Thread，new一个Thread然后去重写它的Run 方法.start才可以运行，或者以前就是你写了一个Runnable你也必须得new一个Thread出来，以 前的这种定义和运行是固定的，是写死的就是你new一个Thread让他出来运行。有的同学他还是new一个Thread但是他有了各种各样新的玩法，不用你亲自去指定每一个Thread，他的运行的方 式你可以自己去定义了，所以至于是怎么去定义的就看你怎么实现Executor的接口了，这里是定 义和运行分开这么一个含义，所以这个接口体现的是这个意思，所以这个接口就比较简单，至于你 是直接调用run还是new一个Thread那是你自己的事儿。

```java
* The {@code Executor} implementations provided in this package
 * implement {@link ExecutorService}, which is a more extensive
 * interface.  The {@link ThreadPoolExecutor} class provides an
 * extensible thread pool implementation. The {@link Executors} class
 * provides convenient factory methods for these Executors.
 *
 * <p>Memory consistency effects: Actions in a thread prior to
 * submitting a {@code Runnable} object to an {@code Executor}
 * <a href="package-summary.html#MemoryVisibility"><i>happen-before</i></a>
 * its execution begins, perhaps in another thread.
 *
 * @since 1.5
 * @author Doug Lea
 */
public interface Executor {
    /**
     * Executes the given command at some time in the future.  The command
     * may execute in a new thread, in a pooled thread, or in the calling
     * thread, at the discretion of the {@code Executor} implementation.
     *
     * @param command the runnable task
     * @throws RejectedExecutionException if this task cannot be
     * accepted for execution
     * @throws NullPointerException if command is null
     */
    void execute(Runnable command);
}
```

* **ExecutorService** 是什么意思呢，他是从Executor继承，另外，他除了去实现Executor可以去执 行一个任务之外，他还完善了整个任务执行器的一个生命周期，就拿线程池来举例子，一个线程池 里面一堆的线程就是一堆的工人，执行完一个任务之后我这个线程怎么结束啊，线程池定义了这样 一些个方法:

  ```java
  void shutdown();//结束
  List<Runnable> shutdownNow();//马上结束
  boolean isShutdown();//是否结束了
  boolean isTerminated();//是不是整体都执行完了
  boolean awaitTermination(long timeout, TimeUnit unit)
  throws InterruptedException;//等着结束，等多长时间，时间到了还不结束的话他 就返回false
  ```

  等等，所以这里面呢，他是实现了一些个线程的线程池的生命周期的东西，扩展了Executor的接 口，真正的线程池的现实是在ExecutorService的这个基础上来实现的。当我们看到这个 ExecutorService的时候你会发现他除了Executor执行任务之外还有submit提交任务，执行任务是 直接拿过来马上运行，而submit是扔给这个线程池，什么时候运行由这个线程池来决定，相当于 是异步的，我只要往里面一扔就不管了。那好，如果不管的话什么时候他有结果啊，这里面就涉及 了比较新的类:比如说Future、RunnableFuture、FutureTask所以在这个里面我要给大家拓展一 些线程的基础的概念，大家以前学线程的时候定义一个线程的任务只能去实现Runnable接口，那 在1.5之后他就增加了Callable这个接口。

  *下面代码我们看一下Callable这个文档，他说这个接口和java.lang.Runnable类似，所以这两个类 设计出来都是想潜在的另外一个线程去运行他，所以通过这点你会知道Callable和Runnable一样 他也可以是一个线程来运行他，那好，为什么有了Runnable还要有Callable，很简单看代码 Callable有一个返回值，call这个方法相当与Runnable里面的run方法，而Runnable里的方法返回 值是空值，而这里是可以有一个返回值的，给你一个计算的任务，最后你得给我一个结果啊，这个 叫做Callable，那么由于他可以返回一个结果，我就可以把这个结果给存储起来，等什么时候您老 人家计算完了通知我就可以了，我就不需要像原来线程池里面我调用他的run在这等着了。

  所以有了这个Callable之后就有了很多种新鲜的玩法，Callable是什么，他类似于Runnable，不过 Callable可以有返回值。



```java
package java.util.concurrent;

/**
 * A task that returns a result and may throw an exception.
 * Implementors define a single method with no arguments called
 * {@code call}.
 *
 * <p>The {@code Callable} interface is similar to {@link
 * java.lang.Runnable}, in that both are designed for classes whose
 * instances are potentially executed by another thread.  A
 * {@code Runnable}, however, does not return a result and cannot
 * throw a checked exception.
 *
 * <p>The {@link Executors} class contains utility methods to
 * convert from other common forms to {@code Callable} classes.
 *
 * @see Executor
 * @since 1.5
 * @author Doug Lea
 * @param <V> the result type of method {@code call}
 */
@FunctionalInterface
public interface Callable<V> {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}

```

* 有了这个Callable之后呢，我们在来看一个接口:Future，这个Future代表的是什么呢，这个 Future代表的是那个Callable被执行完了之后我怎么才能拿到那个结果啊，它会封装到一个Future 里面。Future将来，未来。未来你执行完之后可以把这个结果放到这个未来有可能执行完的结果 里头，所以Future代表的是未来执行完的一个结果。

  由于Callable基本上就是为了线程池而设计的，所以你要是不用线程池的接口想去写Callable的一 些个小程序还是比较麻烦，所以这里面是要用到一些线程池的直接的用法，比较简单，我们先用， 用完后再给大家解释什么意思。我们来看Future是怎么用的，在我们读这个ExecutorService的时 候你会发现他里面有submit方法，这个submit是异步的提交任务，提交完了任务之后原线程该怎 么运行怎么运行，运行完了之后他会出一个结果，这个结果出在哪儿 ，他的返回值是一个 Future，所以你只能去提交一个Callable，必须有返回值，把Callable的任务扔给线程池，线程池 执行完了，异步的，就是把任务交给线程池之后我主线程该干嘛干嘛，调用get方法直到有结果之 后get会返回。Callable一般是配合线程池和Future来用的。

  其实更灵活的一个用法是FutureTask，即是一个Future同时又是一个Task，原来这Callable只能一 个Task只能是一个任务但是他不能作为一个Future来用。这个FutureTask相当于是我自己可以作 为一个任务来用，同时这个任务完成之后的结果也存在于这个对象里，为什么他能做到这一点，因 为FutureTask他实现了RunnableFuture，而RunnableFuture即实现了Runnable又实现了 Future，所以他即是一个任务又是一个Future。所以这个FutureTask是更好用的一个类。大家记 住这个类，后面还会有WorkStealingPool、ForkJoinPool这些个基本上是会用到FutureTask类 的。

  

```java
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
import java.util.concurrent.TimeUnit;

public class T06_00_Future {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        FutureTask<Integer> task = new FutureTask<>(() -> {
            TimeUnit.MILLISECONDS.sleep(500);
            return 1000;
        }); //new Callable () { Integer call();}
        new Thread(task).start();
        System.out.println(task.get()); //阻塞
    }
}
```



我们拓展了几个类，大家把这几个小类理解一下

* Callable 类似与 Runnable，但是有返回值。

* 了解了Future，是用来存储执行的将来才会产生的结果。

* FutureTask，他是Future加上Runnable，既可以执行又可以存结果。

* CompletableFuture，管理多个Future的结果。

有了这些之后，我们可以介绍一个**CompletableFuture**。他底层特别复杂，但是用法特别灵活， 如果你们感兴趣可以去拓展的了解一下，用一下。CompletableFuture他的底层用的是ForkJoinPool。

我们先来看他的用法，这里有一个小例子，有这样一个情景可以用到这个CompletableFuture，这个 CompletableFuture非常的灵活，它内部有好多关于各种结果的一个组合，这个CompletableFuture是 可以组合各种各样的不同的任务，然后等这个任务执行完产生一个结果进行一个组合。我们直接看代 码，假如你自己写了一个网站，这个网站都卖格力空调，同一个类型，然后很多人买东西都会进行一个 价格比较，而你提供的这个服务就是我到淘宝上去查到这个格力空调买多少钱，然后我另启动一个线程 去京东上找格力空调卖多少钱，在启动一个线程去拼多多上找，最后，我给你汇总一下这三个地方各售 卖多少钱，然后你自己再来选去哪里买。下面代码，模拟了一个去别的地方取价格的一个方法，首先你 去别的地方访问会花好长时间，因此我写了一个delay() 让他去随机的睡一段时间，表示我们要联网， 我们要爬虫爬结果执行这个时间，然后打印了一下睡了多少时间之后才拿到结果的，如拿到天猫上的结 果是1块钱，淘宝上结果是2块钱，京东上结果是3块钱，总而言之是经过网络爬虫爬过来的数据分析出 来的多少钱。然后我们需要模拟一下怎么拿到怎么汇总，第一种写法就是我注释的这种写法，就是挨着 牌的写，假设跑天猫跑了10秒，跑淘宝拍了10秒，跑京东跑了5秒，一共历时25秒才总出来。但是如果 我用不同的线程呢，一个一个的线程他们是并行的执行他们计算的结果是只有10秒。

但是用线程你写起来会有各种各样的麻烦事儿，比如说在去淘宝的过程中网络报错了该怎么办，你去京 东的过程中正好赶上那天他活动，并发访问特别慢你又该怎么办，你必须得等所有的线程都拿到之后才 能产生一个结果，如果想要做这件事儿的话与其是要你每一个都要写一个自己的线程，需要考虑到各种 各样的延迟的问题，各种各样的异常的问题这个时候有一个简单的写法，用一个CompletableFuture， 首先第一点CompletableFuture他是一个Future，所以他会存一个将来有可能产生的结果值，结果值是 一个Double，它会运行一个任务，然后这个任务最后产生一个结果，这个结果会存在 CompletableFuture里面，结果的类型是Double。

在这里我就定义了三个Future，分别代表了淘宝、京东、天猫，用了CompletableFuture的一个方法叫 supplyAsync产生了一个异步的任务，这个异步的任务去天猫那边去给我拉数据去。你可以想象在一个 线程池里面扔给他一个任务让他去执行，什么时候执行完了之后他的结果会返回到这个futureTM里 面。但是总体的要求就是这些个所有的future都得结束才可以，才能展示我最后的结果。

往下走还有这么一直写法，就是我把这三个future都可以扔给一个CompletableFuture让他去管理，他 管理的时候可以调用allOf方法相当于这里面的所有的任务全部完成之后，最后join，你才能够继续往下 运行。所以CompletableFuture除了提供了比较好用的对任务的管理之外，还提供了对于任务堆的管 理，用于对一堆任务的管理。CompletableFuture还提供了很多的写法，比如下面Lambda表达式的写 法。

CompletableFuture是什么东西呢?他是各种任务的一种管理类，总而言之呢CompletableFuture是一 个更高级的类，它能够在很高的一个层面上来帮助你管理一些个你想要的各种各样的任务，比如说你可 以对任务进行各种各样的组合 ，所有任务完成之后你要执行一个什么样的结果，以及任何一个任务完成 之后你要执行一个什么样的结果，还有他可以提供一个链式的处理方式Lambda的一些写法，拿到任务 之后结果进行一个怎样的处理。



```java
/**
 * /* 假设你能够提供一个服务
 * /* 这个服务查询各大电商网站同一类产品的价格并汇总展示 * @author 马士兵 http://mashibing.com
 */
package com.mashibing.juc.c_026_01_ThreadPool;

import java.io.IOException;
import java.util.Random;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.function.Supplier;

public class T06_01_CompletableFuture {
    public static void main(String[] args) throws ExecutionException,
            InterruptedException {
        long start, end;
        /*start = System.currentTimeMillis();
        priceOfTM();
        priceOfTB();
        priceOfJD();
        end = System.currentTimeMillis();
        System.out.println("use serial method call! " + (end - start));
        */
        start = System.currentTimeMillis();
        CompletableFuture<Double> futureTM = CompletableFuture.supplyAsync(() -> priceOfTM());
        CompletableFuture<Double> futureTB = CompletableFuture.supplyAsync(() -> priceOfTB());
        CompletableFuture<Double> futureJD = CompletableFuture.supplyAsync(() -> priceOfJD());
        CompletableFuture.allOf(futureTM, futureTB, futureJD).join();
        CompletableFuture.supplyAsync(() -> priceOfTM())
                .thenApply(String::valueOf)
                .thenApply(str -> "price " + str)
                .thenAccept(System.out::println);
        end = System.currentTimeMillis();
        System.out.println("use completable future! " + (end - start));
        try {
            System.in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static double priceOfTM() {
        delay();
        return 1.00;
    }

    private static double priceOfTB() {
        delay();
        return 2.00;
    }

    private static double priceOfJD() {
        delay();
        return 3.00;
    }

    /*private static double priceOfAmazon() {
        delay();
        throw new RuntimeException("product not exist!");
    }*/
    private static void delay() {
        int time = new Random().nextInt(500);
        try {
            TimeUnit.MILLISECONDS.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
      System.out.printf("After %s sleep!\n", time);
    }
}

```

我们在来了解一下线程池，线程池呢从目前JDK提供的有两种类型，第一种就是普通的线程池 **ThreadPoolExecutor**，第二种是**ForkJoinPool**，这两种是不同类型的线程池，能干的事儿不太一 样，大家先把结论记住。Fork分叉，分叉完再分叉，最后的结果汇总这叫join。给大家讲一个故事，在 我上大学的时候NASA美国航天局他们有很多的数据，计算机的计算力不行，就想了办法，他把哪些要 计算的气象或者宇宙中产生各种各样的数据进行一个分片，一大块儿数据分成一小片一小片的，然后自己的计算机确实算不过来，太多了，他就向全球发出请求，你们愿不愿意在计算机空余的时间来帮我做 一些这样的饿计算，他是干过这样的一个事情的，我在上大学的时候是收到过NASA这样一个申请的。 所以这个就是ForkJoinPool的一个概念。这是两种不同类型的线程池，我们说线程池的时候一般是说的 第一种线程池，严格来讲这两种是不一样的，今天我先来对ThreadPoolExecutor进行一个入门，后面 我们再来讲ForkJoinPool。

ThreadPoolExecutor他的父类是从AbstractExecutorService，而AbstractExecutorService的父类是 ExecutorService，再ExecutorService的父类是Executo，所以ThreadPoolExecutor就相当于线程池的 执行器，就是大家伙儿可以向这个池子里面扔任务，让这个线程池去运行。另外在阿里巴巴的手册里面 要求线程池是要自定义的，还有不少同学会被问这个线程池是怎么自定义。

我们来看怎么样手动定义一个线程池，手动定义线程池他有很多构造方法，我们找这个最常见的理解了 就行了。大家看下面这里代码，我定义了一个任务Task，这个任务是实现Runnable接口，就是一个普 通的任务了，每一个任务里有一个编号i，然后打印这个编号，主要干这个事儿，打印完后阻塞 System.in.read()，每个任务都是阻塞的，toString方法就不说了，定义一个线程池最长的有七个参数， 首先我们来理解什么叫线程池，线程池他维护这两个集合，第一个是线程的集合，里面是一个一个的线 程。第二个是任务的集合，里面是一个一个的任务这叫一个完整的线程池。

我怎么定义这一个线程池，这里面的七个参数，

* 第一个参数**corePoolSoze****核心线程数**，最开始的时候是有这个线程池里面是有一定的核心线程数 的;

* 第二个叫**maximumPoolSize****最大线程数**，线程数不够了，能扩展到最大线程是多少; **
* **第三个**keepAliveTime生存时间**，意思是这个线程有很长时间没干活了请你把它归还给操作系统; **
* **第四个**TimeUnit.SECONDS生存时间的单位**到底是毫秒纳秒还是秒自己去定义;

* 第五个是**任务队列**，就是我们上节课讲的BlockingQueue，各种各样的BlockingQueue你都可以 往里面扔，我们这用的是ArrayBlockingQueue，参数最多可以装四个任务;

* 第六个是**线程工厂**defaultThreadFactory，他返回的是一个enw DefaultThreadFactory,它要去你 去实现ThreadFactory的接口，这个接口只有一个方法叫newThread，所以就是产生线程的，可以 通过这种方式产生自定义的线程，默认产生的是defaultThreadFactory，而defaultThreadFactory 产生线程的时候有几个特点:new出来的时候指定了group制定了线程名字，然后指定的这个线程 绝对不是守护线程，设定好你线程的优先级。自己可以定义产生的到底是什么样的线程，指定线程 名叫什么(为什么要指定线程名称，有什么意义，就是可以方便出错是回溯);

* 第七个叫**拒绝策略**，指的是线程池忙，而且任务队列满这种情况下我们就要执行各种各样的拒绝策 略，jdk默认提供了四种拒绝策略，也是可以自定义的。

1:Abort:抛异常 2:Discard:扔掉，不抛异常 3:DiscardOldest:扔掉排队时间最久的 4:CallerRuns:调用者处理服务

一般情况这四种我们会自定义策略，去实现这个拒绝策略的接口，处理的方式是一般我们的消息需 要保存下来，要是订单的话那就更需要保存了，保存到kafka，保存到redis或者是存到数据库随便 你然后做好日志。

```java
package com.mashibing.juc.c_026_01_ThreadPool;

import java.io.IOException;
import java.util.concurrent.*;

public class T05_00_HelloThreadPool {
    static class Task implements Runnable {
        private int i;
        public Task(int i) {
            this.i = i;
        }

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + " Task " + i);
            try {
                System.in.read();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        @Override
        public String toString() {
            return "Task{" +
                    "i=" + i + '}';
        }
    }

    public static void main(String[] args) {
        ThreadPoolExecutor tpe = new ThreadPoolExecutor(2, 4,
                60, TimeUnit.SECONDS,
                new ArrayBlockingQueue<Runnable>(4),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.CallerRunsPolicy());

        for (int i = 0; i < 8; i++) {
            tpe.execute(new Task(i));
        }
        System.out.println(tpe.getQueue());
        tpe.execute(new Task(100));
        System.out.println(tpe.getQueue());
        tpe.shutdown();
    }
}
```

今天将了很多，复习的时候你就把一个一个小程序从头到尾看完，看懂意思之后自己去敲，前面呢 我们通过一道面试题来复习了之前学的一些方法，重点是LockSupport以及 synchronized_wait_notify。然后我们讲了ThreadPool的一个入门，讲ThreadPool的时候我们给大家 扩展了Callable和Runnable的不同，Future用来存储执行的将来才会产生的结果、FutureTask，他是 Future加上Runnable，既可以执行又可以存结果、CompletableFuture，管理各种各样的Future的结果。

# 第八节：线程池与源码阅读