

# 前言

-----

2019版多线程与高并发(马士兵)

各位同学，大家好，这是首次使用比较口语化的文字形成一本书，其实也不知道效果如何，希望各位收
到书本后能够多提意见和建议。同时也请大家体谅，由于时间关系和忙碌程度，暂时只能总结成为口语
化的形式，后面时间充裕了，将会将会以书面语言的方式进行重新更新。

# 第一节：线程的基本概念

----

首先大家交代一下我们2019年这个版本给大家讲哪些内容，这个版本主要之中在多线程和高并发这两 大块，这两大块儿是现在面试问的越来越多，也是相对一个初级的程序员向中高级迈进的必须要踏过的 一个坎儿。

多线程与高并发大概讲六大块，

* 第一:**基本的概念**，从什么是线程开始
* 第二:**JUC****同步工具**，就是各种同步锁
* 第三:**同步容器**
* 第四:**线程池** 
* 第五:**高频面试加分项**的一些面试用的东西，包括纤程 
* 第六:**Disruptor**，不知道有多少同学听说过这个框架的，这个框架它也是一个MQ框架 (Message Queue)叫做消息队列，消息队列非常多，后面还会给大家讲Kafka、RabbitMQ， Redis等这些都是消息队列。Disruptor是目前大家公认的在单机环境上效率最高的、性能最快的 MQ。

![多线程与高并发2019](/Users/dev/Desktop/多线程/img/多线程与高并发2019.png)

***我们先说一下为什么要讲多线程和高并发?***

原因是，你想拿到一个更高的薪水，在面试的时候呈现出了两个方向的现象: 

第一个是**上天**

* 项目经验
* 高并发 缓存 大流量 大数据量的架构设计

第二个是**入地** 

* 各种基础算法，各种基础的数据结构

* JVM OS 线程 IO等内容 

多线程和高并发，就是**入地**里面的内容。

**基本概念**

我们先从线程的基本概念开始，给大家复习一下，不知道有多少同学是基础不太好，说什么是线程都不
知道的，如果这样的话，花时间去补初级内容的课。

![image-20200614183901177](/Users/dev/Library/Application Support/typora-user-images/image-20200614183901177.png)

什么是叫一个进程? 什么叫一个线程?

* Program app ->QQ.exe

**进程:**做一个简单的解释，你的硬盘上有一个简单的程序，这个程序叫QQ.exe，这是一个程序， 这个程序是一个静态的概念，它被扔在硬盘上也没人理他，但是当你双击它，弹出一个界面输入账 号密码登录进去了，OK，这个时候叫做一个进程。进程相对于程序来说它是一个动态的概念

**线程:**作为一个进程里面最小的执行单元它就叫一个线程，用简单的话讲一个程序里不同的执行路 径就叫做一个线程

**示例:什么叫做线程**

```java
package com.mashibing.juc.c_000;
import java.util.concurrent.TimeUnit;
public class T01_WhatIsThread {
  private static class T1 extends Thread {
    @Override
    public void run() {
       for(int i=0; i<10; i++) {
           try {
               TimeUnit.MICROSECONDS.sleep(1);
           } catch (InterruptedException e) {
               e.printStackTrace();
}
           System.out.println("T1");
       }
} }
  
public static void main(String[] args) {
    //new T1().run();
    new T1().start();
    for(int i=0; i<10; i++) {
    try {
        TimeUnit.MICROSECONDS.sleep(1);
    } catch (InterruptedException e) {
        e.printStackTrace();
}
    System.out.println("main");
}


```

观察上面程序的数据结果，你会看到字符串“T1”和“Main”的交替输出，这就是程序中有两条不同的执行 路径在交叉执行，这就是直观概念上的线程，***概念性的东西，理解就好，没有必要咬文嚼字的去背文字 的定义***。

**创建线程的几种方式**

} }

```java

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.FutureTask;
public class T02_HowToCreateThread {

    static class MyThread extends Thread {
         @Override
        public void run() {
            System.out.println("Hello MyThread!");
    } 
     }
    static class MyRun implements Runnable {
        @Override
        public void run() {
            System.out.println("Hello MyRun!");
} }

   static class MyCall implements Callable<String> {
        @Override
        public String call() {
            System.out.println("Hello MyCall");
            return "success";
} }
  
  //启动线程的5种方式
public static void main(String[] args) {
       // 1:
        new MyThread().start();
      // 2:
        new Thread(new MyRun()).start();
     // 3:
        new Thread(()->{
            System.out.println("Hello Lambda!");
        }).start();
     // 4:
        Thread t = new Thread(new FutureTask<String>(new MyCall()));
        t.start();
    // 5:
        ExecutorService service = Executors.newCachedThreadPool();
        service.execute(()->{
            System.out.println("Hello ThreadPool");
        });
        service.shutdown();
    }
}

```

**分享一道面试题**

请你告诉我启动线程的三种方式 ?

* 你说第一个:new Thread().start(); 

* 第二个: new Thread(Runnable).start() 这没问题 ;

* 那第三个呢， 要回答线程池也是用的这两种之一，他这么问有些吹毛求疵的意思，你就可以说通过线程池也可以启动 一个新的线程 3:Executors.newCachedThreadPool()或者FutureTask + Callable

```java
package com.mashibing.juc.c_000;
public class T03_Sleep_Yield_Join {
    public static void main(String[] args) {
                    //testSleep();
                    //testYield();
        testJoin();
    }
/*Sleep,意思就是睡眠，当前线程暂停一段时间让给别的线程去运行。Sleep是怎么复活的?由 你的睡眠时间而定，等睡眠到规定的时间自动复活*/
    static void testSleep() {
        new Thread(()->{
            for(int i=0; i<100; i++) {
                System.out.println("A" + i);
                try {
                      Thread.sleep(500);
                  //TimeUnit.Milliseconds.sleep(500)
                } catch (InterruptedException e) {
                    e.printStackTrace();
} }
        }).start();
    }
/*Yield,就是当前线程正在执行的时候停止下来进入等待队列，回到等待队列里在系统的调度算 法里头呢还是依然有可能把你刚回去的这个线程拿回来继续执行，当然，更大的可能性是把原来等待的那些拿 出一个来执行，所以yield的意思是我让出一下CPU，后面你们能不能抢到那我不管*/
    static void testYield() {
        new Thread(()->{
            for(int i=0; i<100; i++) {
                System.out.println("A" + i);
                if(i%10 == 0) Thread.yield();
            }
        }).start();
        new Thread(()->{
            for(int i=0; i<100; i++) {
                System.out.println("------------B" + i);
                if(i%10 == 0) Thread.yield();
            }
        }).start();
    }
/*join， 意思就是在自己当前线程加入你调用Join的线程()，本线程等待。等调用的线程运行 完了，自己再去执行。t1和t2两个线程，在t1的某个点上调用了t2.join,它会跑到t2去运行，t1等待t2运 行完毕继续t1运行(自己join自己没有意义) */
    static void testJoin() {
        Thread t1 = new Thread(()->{
            for(int i=0; i<100; i++) {
                System.out.println("A" + i);
                try {
                    Thread.sleep(500);
                    //TimeUnit.Milliseconds.sleep(500)
                } catch (InterruptedException e) {
                    e.printStackTrace();
} }
        });
        Thread t2 = new Thread(()->{
            try {
                t1.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
}
            for(int i=0; i<100; i++) {
                System.out.println("A" + i);
                try {
                    Thread.sleep(500);
                    //TimeUnit.Milliseconds.sleep(500)
                } catch (InterruptedException e) {
                    e.printStackTrace();
                  } }
});
        t1.start();
        t2.start();
    }
}
```



![image-20200614185015486](/Users/dev/Library/Application Support/typora-user-images/image-20200614185015486.png)

常见的线程状态有六种: 当我们new一个线程时，还没有调用start()该线程处于**新建状态**

线程对象调用 start()方法时候，他会被线程调度器来执行，也就是交给操作系统来执行了，那么操 作系统来执行的时候，这整个的状态叫Runnable，Runnable内部有两个状态

**(1)Ready****就绪状 态**/**

(2)Running运行状态**。就绪状态是说扔到CPU的等待队列里面去排队等待CPU运行，等真正扔到 CPU上去运行的时候才叫Running运行状态。(调用yiled时候会从Running状态跑到Ready状态去，线 程配调度器选中执行的时候又从Ready状态跑到Running状态去)

如果你线程顺利的执行完了就会进去

**(3)Teminated****结束状态**，(需要注意Teminated完了之后还可不 可以回到new状态再调用start?这是不行的，完了这就是结束了)

在Runnable这个状态里头还有其他一些状态的变迁

**(4)TimedWaiting****等待**、**

(5)Waiting等待**、 **

(6)Blocked阻塞**，在同步代码块的情况就下没得到锁就会**阻塞状态**，获得锁的时候是就绪状态运行。在 运行的时候如果调用了o.wait()、t.join()、LockSupport.park()进入**Waiting状态**，调用o.notify()、 o.notifiAll()、LockSupport.unpark()就又回到Running状态。**TimedWaiting**按照时间等待，等时间结 束自己就回去了，

* Thread.sleep(time)、

* o.wait(time)、

* t.jion(time)、

* LockSupport.parkNanos()、

* LockSupport.parkUntil() 这些都是关于时间等待的方法。

** 问题****1****:哪些是****JVM****管理的?哪些是操作系统管理的?**

上面这些状态全是由JVM管理的，因为JVM管理的时候也要通过操作系统，所以呢，那个是操作系统和

那个是JVM他俩分不开，JVM是跑在操作系统上的一个普通程序

**问题****2****:线程什么状态时候会被挂起?挂起是否也是一个状态?**

Running的时候，在一个cpu上会跑很多个线程，cpu会隔一段时间执行这个线程一下，在隔一段时间执 行那个线程一下，这个是cpu内部的一个调度，把这个状态线程扔出去，从running扔回去就叫线程被 挂起，cpu控制它。

来看一下ThraedState这段代码



```java
package com.mashibing.juc.c_000;
public class T04_ThreadState {
    static class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println(this.getState());

          for(int i=0; i<10; i++) {
              try {
                  Thread.sleep(500);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              System.out.println(i);
          }
         }
      }


public static void main(String[] args) {
    Thread t = new MyThread();
    //怎么样得到这个线程的状态呢?就是通过getState()这个方法 
  System.out.println(t.getState());//他是一个new状态
     t.start();//到这start完了之后呢是Runnable的状态
    try {
        t.join();
    } catch (InterruptedException e) {
        e.printStackTrace();
}
//然后join之后，结束了是一个Timenated状态 
  System.out.println(t.getState()); 
 }
}

```

**synchronized**

下面我们来讲synchronized关键字，有不少同学已经耳熟能详了，不过作为复习还是要复习一下。第一 个是多个线程去访问同一个资源的时候对这个资源上锁。

为什么要上锁呢?访问某一段代码或者某临界资源的时候是需要有一把锁的概念在这儿的。

![image-20200614185946179](/Users/dev/Library/Application Support/typora-user-images/image-20200614185946179.png)

比如：我们对一个数字做递增，两个程序对它一块儿来做递增，递增就是把一个程序往上加1啊，如果 两个线程共同访问的时候，第一个线程一读它是0，然后把它加1，在自己线程内部内存里面算还没有写 回去的时候而第二个线程读到了它还是0，加1在写回去，本来加了两次，但还是1，那么我们在对这个 数字递增的过程当中就上把锁，就是说第一个线程对这个数字访问的时候是独占的，不允许别的线程来 访问，不允许别的线程来对它计算，我必须加完1收释放锁，其他线程才能对它继续加。

实质上，这把锁并不是对数字进行锁定的， 你可以任意指定，想锁谁就锁谁。

我第一个小程序是这么写的 ，如果说你想上了把锁之后才能对count进行减减访问，你可以new一个 Object，所以这里锁定就是o，当我拿到这把锁的时候才能执行这段代码。是锁定的某一个对象， synchronized有一个锁升级的概念，我们一会儿会讲到

```java
/**
*synchronized关键字
*对某个对象加锁
*@author mashibing
*/
package com.mashibing.juc.c_001;
public class T {
    private int count = 10;
    private Object o = new Object();
		public void m() {
		synchronized(o) { //任何线程要想执行下面的代码，必须先拿到o的锁
        count--;
        System.out.println(Thread.currentThread().getName() + " count = " +count); 
		} 
	} 
}
```

***如果你要是锁定当前对象呢***，你也可以写成如下方法。synchronized方法和synchronized(this)执行这 段代码它是等值的

```java
package com.mashibing.juc.c_003;
public class T {
    private int count = 10;
    public synchronized void m() { //等同于在方法的代码执行时要synchronized(this) count--;
    System.out.println(Thread.currentThread().getName() + " count = " +count);

	} 
}
```

静态方法static是没有this对象的，你不需要new出一个对象来就能执行这个方法，但如果这个 这个上面加一个synchronized的话就代表synchronized(T.class)。这里这个synchronized(T.class)锁的 就是T类的对象

```java
package com.mashibing.juc.c_004;
public class T {
    private static int count = 10;
    //这里等同于synchronized(T.class) count--;
    public synchronized static void m() { 
         System.out.println(Thread.currentThread().getName() + " count = " +count);
}
public static void mm() {
  //考虑一下这里写synchronized(this)是否可以?
 synchronized(T.class) { 
 	count --; 
 	}
 }
}


```

**问题:****T.class****是单例的吗?**

一个class load到内存它是不是单例的，想想看。一般情况下是，如果是在同一个ClassLoader空间那它 一定是。不是同一个类加载器就不是了，不同的类加载器互相之间也不能访问。所以说你能访问它，那 他一定就是单例

下面程序:很有可能读不到别的线程修改过的内容，除了这点之外count减减完了之后下面的count输 出和你减完的结果不对，很容易分析:如果有一个线程把它从10减到9了，然后又有一个线程在前面一 个线程还没有输出呢进来了把9又减到了8，继续输出的8，而不是9。如果你想修正它，前面第一个是在 上面加volatile，改了马上就能得到。

```java

/**
 * 分析一下这个程序的输出 
* @author mashibing
*  */
package com.mashibing.juc.c_005;
public class T implements Runnable {
    private /*volatile*/ int count = 100;
    public /*synchronized*/ void run() {
        count--;
        System.out.println(Thread.currentThread().getName() + " count = " +
count);
}
 public static void main(String[] args) {
        T t = new T();
        for(int i=0; i<100; i++) {
            new Thread(t, "THREAD" + i).start();
            } 
            }

}
```

另外这个之外还可以加***synchronized***，加了synchronized就没有必要在加volatile了，因为 synchronized既保证了原子性，又保证了可见性

//对比上一个小程序
 package com.mashibing.juc.c_006; public class T implements Runnable {

```
    private int count = 10;
    public synchronized void run() {
        count--;
          System.out.println(Thread.currentThread().getName() + " count = " +
count);
    }
    public static void main(String[] args) {
} }
for(int i=0; i<5; i++) {
    T t = new T();
    new Thread(t, "THREAD" + i).start();
}



```



如下代码:同步方法和非同步方法是否可以同时调用?就是我有一个synchronized的m1方法，我调用 m1的时候能不能调用m2，拿大腿想一想这个是肯定可以的，线程里面访问m1的时候需要加锁，可是 访问m2的时候我又不需要加锁，所以允许执行m2。

这些小实验的设计是比较考验功力的，学习线程的时候自己要多动手进行试验，任何一个理论，都可以
进行验证.

```java
/** *同步和非同步方法是否可以同时调用? * @author mashibing
*/
package com.mashibing.juc.c_007;
public class T {
    public synchronized void m1() {
        System.out.println(Thread.currentThread().getName() + " m1 start...");
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + " m1 end");
    }
    public void m2() {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + " m2 ");
    }
    public static void main(String[] args) {
        T t = new T();
        /*new Thread(()->t.m1(), "t1").start();
        new Thread(()->t.m2(), "t2").start();*/
				new Thread(t::m1, "t1").start();
        new Thread(t::m2, "t2").start();
/*
//1.8之前的写法
new Thread(new Runnable() {
    @Override
    public void run() {
t.m1(); }
});
*/
      
    }
}
```



我们在来看一个synchronized应用的例子

我们定义了一个class账户，有名称、余额。写方法给哪个用户设置它多少余额，读方法通过这个名字得 到余额值。如果我们给写方法加锁，给读方法不加锁，你的业务允许产生这种问题吗?业务说我中间读 到了一些不太好的数据也没关系，如果不允许客户读到中间不好的数据那这个就有问题。正因为我们加 了锁的方法和不加锁的方法可以同时运行。

**问题**比如说:张三，给他设置100块钱启动了，睡了1毫秒之后呢去读它的值，然后再睡2秒再去读它的 值这个时候你会看到读到的值有问题，原因是在设定的过程中this.name你中间睡了一下，这个过程当 中我模拟了一个线程来读，这个时候调用的是getBalance方法，而调用这个方法的时候是不用加锁的， 所以说我不需要等你整个过程执行完就可以读到你中间结果产生的内存，这个现象就叫做脏读。这问题 的产生就是synchronized方法和非synchronized方法是同时运行的。**解决**就是把getBalance加上 synchronized就可以了，如果你的业务允许脏读，就可以不用加锁，加锁之后的效率低下



```
/**
* 面试题:模拟银行账户
* 对业务写方法加锁
* 对业务读方法不加锁
* 这样行不行? *
* 容易产生脏读问题(dirtyRead) */
package com.mashibing.juc.c_008;
import java.util.concurrent.TimeUnit;
public class Account {
    String name;
    double balance;
    public synchronized void set(String name, double balance) {
        this.name = name;
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
  this.balance = balance;
    }
    public /*synchronized*/ double getBalance(String name) {
        return this.balance;
}
    public static void main(String[] args) {
        Account a = new Account();
        new Thread(()->a.set("zhangsan", 100.0)).start();
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
}
        System.out.println(a.getBalance("zhangsan"));
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
}
        System.out.println(a.getBalance("zhangsan"));
    }
}        
        

```

再来看synchronized的另外一个属性:可重入，是synchronized必须了解的一个概念。

如果是一个同步方法调用另外一个同步方法，有一个方法加了锁，另外一个方法也需要加锁，加的是同 一把锁也是同一个线程，那这个时候申请仍然会得到该对象的锁。比如说是synchronized可重入的，有 一个方法m1 是synchronized有一个方法m2也是synchrionzed，m1里能不能调m2。我们m1开始的时 候这个线程得到了这把锁，然后在m1里面调用m2，如果说这个时候不允许任何线程再来拿这把锁的时 候就死锁了。这个时候调m2它发现是同一个线程，因为你m2也需要申请这把锁，它发现是同一个线程 申请的这把锁，允许，可以没问题，这就叫可重入锁。

```
/**
* 一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到
该对象的锁。
* 也就是说synchronized获得锁是可重入的 * synchronized
* @author mashibing
*/
package com.mashibing.juc.c_009;
import java.util.concurrent.TimeUnit;
public class T {
    synchronized void m1() {
    System.out.println("m1 start");
    try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        m2();
        System.out.println("m1 end");
}
    synchronized void m2() {
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("m2");
    }
    public static void main(String[] args) {
        new T().m1();
} }
```

模拟一个父类子类的概念，父类synchronized，子类调用super.m的时候必须得可重入，否则就会出问 题(调用父类是同一把锁)。所谓的重入锁就是你拿到这把锁之后不停加锁加锁，加好几道，但锁定的 还是同一个对象，去一道就减个1，就是这么个概念。

```java
/* 程序在执行过程中，如果出现异常，默认情况锁会被释放
* 所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。
* 比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适， * 在第一个线程中抛* 出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。
* 因此要非常小心的处理同步业务逻辑中的异常
* @author mashibing
*/
package com.mashibing.juc.c_011;
import java.util.concurrent.TimeUnit;
public class T {
    int count = 0;
    synchronized void m() {
        System.out.println(Thread.currentThread().getName() + " start");
        while(true) {
            count ++;
            System.out.println(Thread.currentThread().getName() + " count = " +
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
						}
            if(count == 5) {
              // 此处抛出异常，锁将被释放，要想不被释放，可以在这里进行
              // catch，然后让循环继续 
            int i = 1/0; 
              System.out.println(i)
            }                      
        }
    }
    public static void main(String[] args) {
        T t = new T();
        Runnable r = new Runnable() {
             @Override
            public void run() {
                t.m();
      }
    };
        new Thread(r, "t1").start();
					try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
				}
        new Thread(r, "t2").start();
    } 
}


```

**synchronized****的底层实现**

* 早期，jdk早期的时候，这个synchronized的底层实现是重量级的，重量级到这个synchronized都 是要去找操作系统去申请锁的地步，这就会造成synchronized效率非常低，java后来越来越开始 处理高并发的程序的时候，很多程序员都不满意，说这个synchrionized用的太重了，我没办法， 就要开发新的框架，不用你原生的了

* 改进，后来的改进才有了锁升级的概念
     关于这个锁升级的概念，我写过一篇文章《我就是厕所所长一、二》，大家可以去找一下，公
    众号里也有，专门以小说的形式讲了这个锁升级到底是怎么样的一个概念

  

  

  这个锁升级的概念呢，是这样的，原来呢都要去找操作系统，要找内核去申请这把锁，到后期做了对 synchronized的一些改进，他的效率比原来要改变了不少，改进的地方。当我们使用synchronized的 时候HotSpot的实现是这样的:上来之后第一个去访问某把锁的线程 比如sync (Object) ，来了之后先在 这个Object的头上面markword记录这个线程。(如果只有第一个线程访问的时候实际上是没有给这个 Object加锁的，在内部实现的时候，只是记录这个线程的ID(**偏向锁**))。

  偏向锁如果有线程争用的话，就升级为**自旋锁**，概念就是(有一个哥们儿在蹲马桶 ，另外来了一个哥 们，他就在旁边儿等着，他不会跑到cpu的就绪队列里去，而就在这等着占用cpu，用一个while的循环 在这儿转圈玩儿， 很多圈之后不行的话就再一次进行升级)。

  自旋锁转圈十次之后，升级为**重量级锁**，重量级锁就是去操作系统那里去申请资源。这是一个锁升级的 过程。

  参考:https://blog.csdn.net/baidu_38083619/article/details/82527461 需要注意并不是CAS的效率就一定比系统锁要高，这个要区分实际情况:

  ***执行时间短(加锁代码)，线程数少，用自旋***
  ***执行时间长，线程数多，用系统锁***

  

  关于效率方面的内容如果暂时不能理解的，等讲到CAS锁的时候再说。

   **内容回顾**

  线程的概念、启动方式、常用方法 

  * synchronized(Object) 不能用String常量 Integer Long 

  * 线程同步 -synchronized

    - 锁的是对象不是代码

    - this XX.class
    -  -锁定方法 非锁定方法 同时执行

    - 锁升级

  偏向锁 记录这个线程的ID
   自旋锁 如果线层争用，就升级为自旋锁(线程数量少) 重量级锁 10次(线程数量多)

  

 

  /**
   \* volatile 关键字，使一个变量在多个线程间可见
   \* A B线程都用到一个变量，java默认是A线程中保留一份copy,这样如果B线程修改了该变量，则A线程未

  必知道

  - \*  使用volatile关键字，会让所有线程都会读到变量的修改值 *

  - \*  在下面的代码中，running是存在于堆内存的t对象中

  - \*  当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个

    copy,并不会每次都去

  - \*  读取堆内存，这样，当线程修改running的值之后，t1线程感知不到，所以不会停止运行 *
  - \*  使用volatile，将会强制所有线程都会去堆内存中读取running的值 *
  - \*  可以阅读这个文章加深讲解
     \* http://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html *

  \* volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能

  替代synchronized
   \* @author mashibing */

  ```
  package com.mashibing.juc.c_012_Volatile;
  import java.util.concurrent.TimeUnit;
  ```

  public class T01_HelloVolatile {
   /*volatile*/ boolean running = true; //对比一下有无volatile的情况下，整个程序运行

  结果的区别

  ```
      void m() {
          System.out.println("m start");
          while(running) {
          }
          System.out.println("m end!");
  ```

  }

  ```
      public static void main(String[] args) {
          T01_HelloVolatile t = new T01_HelloVolatile();
  ```



# 第二节：volatile 与 CAS

### volatile

  我们先来看这个volatile的概念，volatile它是什么意思，现在像大的互联网企业的面试，基本上volatile 是必会的，有时候他也不会太问，认为你应该会，但是中小企业也就开始问这方面的问题。

  我们来看一下这个小程序，写了一个方法啊，首先定义了一个变量布尔类型等于true，这里模拟的是一 个服务器的操作，我的值为true你就给我不间断的运行，什么时候为false你再停止。 测试new Thread 启动一个线程，调用m方法，睡了一秒，最后running等于false，运行方法他是不会停止的。 如果你要 吧volatile打开，那么结果就是启动程序一秒之后他就会m end停止。(volatile就是不停的追踪这个 值，时刻看什么时候发生了变化)



```java
/**
* volatile 关键字，使一个变量在多个线程间可见
* A B线程都用到一个变量，java默认是A线程中保留一份copy,这样如果B线程修改了该变量，则A线程未
必知道
* 使用volatile关键字，会让所有线程都会读到变量的修改值 *
* 在下面的代码中，running是存在于堆内存的t对象中
* 当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个
copy,并不会每次都去
* 读取堆内存，这样，当线程修改running的值之后，t1线程感知不到，所以不会停止运行 *
* 使用volatile，将会强制所有线程都会去堆内存中读取running的值 *
* 可以阅读这个文章加深讲解
* http://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html *
* volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能
   替代synchronized
* @author mashibing 
*/
package com.mashibing.juc.c_012_Volatile;
import java.util.concurrent.TimeUnit;
public class T01_HelloVolatile {
  //对比一下有无volatile的情况下，整个程序运行结果的区别
/*volatile*/ boolean running = true; 
    void m() {
        System.out.println("m start");
        while(running) {
        }
        System.out.println("m end!");
}
    public static void main(String[] args) {
        T01_HelloVolatile t = new T01_HelloVolatile();
      new Thread(t::m, "t1").start();
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
}
        t.running = false;
    }
}

```

***volatile 作用（由于面试常考，必须记住）*** ![02_01](/Users/dev/Desktop/多线程/img/02_01.png)

***

> * 1 保证线程的可见性

大家知道java里面是有堆内存的，堆内存是所有线程共享里面的内存，除了共享的内存之外呢，每个线 程都有自己的专属的区域，都有自己的工作内存，如果说在共享内存里有一个值的话，当我们线程，某 一个线程都要去访问这个值的时候，会将这个值copy一份，copy到自己的这个工作空间里头，然后对 这个值的任何改变，首先是在自己的空间里进行改变，什么时候写回去，就是改完之后会马上写回去。 什么时候去检查有没有新的值，也不好控制。

在这个线程里面发生的改变，并没有及时的反应到另外一个线程里面，这就是线程之间的不可见 ，对这 个变量值加了volatile之后就能够保证 一个线程的改变，另外一个线程马上就能看到。

大家可以去查这个词:MESI ，他的本质上是使用了cpu的一个叫做 高速缓存一致性协议 注:在和面《JVM》的课程中，老师深入讲解了MESI协议和volatile的底层实现。

**2****:禁止指令重新排序**

指令重排序也是和cpu有关系，每次写都会被线程读到，加了volatile之后。cpu原来执行一条指令的时 候它是一步一步的顺序的执行，但是现在的cpu为了提高效率，它会把指令并发的来执行，第一个指令 执行到一半的时候第二个指令可能就已经开始执行了，这叫做流水线式的执行。在这种新的架构的设计 基础之上呢想充分的利用这一点，那么就要求你的编译器把你的源码编译完的指令之后呢可能进行一个 指令的重新排序。

这个是通过实际工程验证了，不仅提高了，而且提高了很多

-DCL单例 我们来聊一聊什么是单例，单例的意思就是我保证你在JVM的内存里头永远只有某一个类的一个实例，

其实这个很容易理解，在我们工程当中有一些类真的没有必要new好多个对象，比如说权限管理者。

单例最简单的写法就是下面这种写法，是说我有一个类，定义了这个类的一个对象，然后一个对象呢是 在个类的内部的，同时我把Mgr01()这个类的构造方法设置成private意思就是别的不要去new我，只有 我自己能new，理论上来说我就只有自己一个实例了，通过getInstance()访问这个实例，所以无论你调 用多少次的getInstanc()本质上它就只有这一个对象，这种写法非常简洁也很容易理解，由JVM来保证永 远只有这一个实例。

```java
 package com.mashibing.dp.singleton;
 /**
 * 饿汉式
 * 类加载到内存后，被实例化一个单例，JVM保证线程安全 * 简单实用，推荐使用!
 * 唯一缺点，不管用到与否，类装载时就完成实例化 * Class.forName("")
 **/
 public class Mgr01{
  private static final Mgr01 INSTANCE = new Mgr01();
  private Mgr01(){};
  public static Mgr01 getInstance(){
    return INSTANCE;
  }
  public void m(){
    System.out.println("m");
  }
  public static void main(String[] args){
    Mgr01 m1=Mgr01.getInstance();
    Mgr01 m2=Mgr02.getInstance();
    System.out.println(m1==m2);
    } 
 }
```

但是有的人，他会吹毛求疵，他会说我还没开始用这个对象呢，没用这个对象调这个方法你干嘛把他初始
化了，你能不能什么时候开始用，调这个方法的时候你再给我初始化。所以呢，下面代码这个是和上一
种一样的写法

```java
package com.mashibing.dp.singleton; /**
* 跟01是一个意思
**/
public class Mgr02{
  private static final Mgr02 INSTANCE;
  static {
    INSTANCE == new Mgr02();
  }
  private Mgr02(){};
  public static Mgr02 getInstance(){return INSTANCE;}
  public void m(){System.out.println("m");}
  public static void main(String[] args){
    Mgr02 m1=Mgr02.getInstance();
    Mgr02 m2=Mgr02.getInstance();
    System.out.println(m1==m2);
 } 
}

```





### CAS







​        







